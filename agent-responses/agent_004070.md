---
Task: Plan enriched loot data architecture
Started: 2025-10-24T07:04:33.839Z
Status: done
Ended: 2025-10-24T07:11:05.185Z
Depth: 0
ParentAgent: root
Prompt: .agent-prompts/agent_004070.txt
PID: 55218
---

I'll create a comprehensive implementation plan for enriching combat loot rewards. Let me first examine the current code structure to understand the exact patterns and dependencies.[UPDATE] Read complete code structure - CombatService already uses repositories for batch fetching, MaterialRepository has single-lookup pattern but no batch method.

Now let me check the rest of the CombatService implementation and type definitions:[UPDATE] Found implementation - CombatService.generateLootFallback() already enriches items with full data from ItemTypeRepository.findByIds() (lines 1543-1582), materials still use direct Supabase queries (1507-1523).

Let me check the type definitions to understand what Material type should include:Let me check the Material type definition in api.types.ts:[UPDATE] Found Material type definition - has id, name, stat_modifiers, base_drop_weight, description. Now analyzing the exact return structure and error pattern CombatService uses.

Let me check what fields ItemTypeRepository.findByIds() returns to match the pattern:Let me check the materialstype definition to understand what fields are available:Let me verify the database schema to understand material fields by examining the migrations:Let me check the main schema file:Let me check what the database schema validation tests show about materials structure:Now I have enough context to create the comprehensive plan. Let me create it:Perfect! I've created a comprehensive implementation plan for enriching combat loot rewards. Here's what the plan covers:

## Plan Overview

**File location:** `/Users/silasrhyneer/Code/new-mystica/docs/plans/loot-enrichment/plan.md`

### Key Points:

**Problem:** CombatService uses mixed patterns—repository for items but direct Supabase queries for materials, making data enrichment inconsistent.

**Solution Structure:**
1. **Task 1**: Add `MaterialRepository.findByIds()` following ItemTypeRepository pattern exactly
2. **Task 2**: Refactor CombatService.generateLootFallback() to use new repository method
3. **Task 3**: Verify error handling and type safety (review-only)
4. **Task 4**: Ensure MaterialRepository is injected into CombatService

**Key Details:**
- No database migrations needed (uses existing schema)
- Error-first approach: throws on missing data, no fallbacks
- All enriched items include: id, name, category, rarity, description, base_stats, appearance_data, style info
- All enriched materials include: id, name, description, stat_modifiers, style info
- Execution order defined with clear dependencies (Task 1→4→2→3)

**Why This Plan Works:**
- **Consistency**: Both ItemType and Material use identical repository pattern
- **Type safety**: Leverages existing Material type from api.types.ts
- **No breaking changes**: Returns same object structure as current code
- **Error handling**: Maintains existing throw-on-missing-data pattern
- **No schema changes**: Works with current database

The plan is detailed enough for programmer agents to execute independently with clear file locations, line numbers, and exact specification of what to implement.

**Assistant:** [exited]
