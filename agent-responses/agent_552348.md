---
Task: Plan profile-init implementation
Instructions: Create a detailed implementation plan for the `/profile/init` API endpoint (POST /profile/init).

## Context

**Feature:** Profile Initialization (F-07 User Authentication)
**Current Status:**
- ✅ Route configured (`src/routes/profile.ts:16`)
- ✅ Controller handler exists (`ProfileController.initProfile`)
- ❌ Service method throws `NotImplementedError` (`ProfileService.initializeProfile`)

**Updated Requirements** (documentation just updated):
- Starting gold: **0 gold** (changed from 500)
- Starting inventory: **1 random common rarity item with no materials applied**
- Must prevent duplicate initialization (idempotency check)
- Returns UserProfile schema
- Creates UserProfile record with defaults

## Technical Environment

**Backend Stack:**
- Express.js + TypeScript
- Supabase PostgreSQL (PostGIS enabled)
- Zod validation (schemas in `src/types/schemas.ts`)
- Service → Controller → Route pattern

**Database Schema** (from `migrations/001_initial_schema.sql`):
- `Users` table: id (PK, UUID from Supabase auth), email, username, vanity_level, avg_item_level
- `UserCurrencyBalances` table: user_id, currency_code ('GOLD'), balance, last_updated
- `Items` table: item_type_id (FK to ItemTypes), user_id, level, rarity (enum), craft_count
- `ItemTypes` table: id, name, slot, base_stats (jsonb), rarity, description
- `UserEquipment` table: user_id, slot (enum), item_id (nullable)

**Key Constraints:**
- Database migration `001_initial_schema.sql` NOT YET APPLIED to Supabase
- Auth middleware uses `null as unknown as SupabaseClient` (broken, needs fix)
- All services currently throw `NotImplementedError`
- NEVER use `any` type - look up actual types
- Throw errors early, don't use fallbacks

**Existing Patterns** (from investigations):
```typescript
// Service pattern example (ItemService)
const { data, error } = await supabase
  .from('TableName')
  .select('*')
  .eq('user_id', userId);

if (error) throw mapSupabaseError(error);
if (!data) throw new NotFoundError('Resource not found');
```

## Implementation Scope

**File to Implement:**
- `src/services/ProfileService.ts:15-25` - `initializeProfile(userId: string)` method

**Requirements:**
1. **Idempotency Check:** Check if profile already exists (query Users table by id)
   - If exists: throw `ConflictError('Profile already initialized')`
   
2. **Create UserProfile:**
   - Insert into `Users` table:
     - id: userId (from Supabase auth)
     - email: fetch from Supabase auth.users
     - username: null (optional, can be set later)
     - vanity_level: 1
     - avg_item_level: 1
   
3. **Initialize Currency Balance:**
   - Insert into `UserCurrencyBalances`:
     - user_id: userId
     - currency_code: 'GOLD'
     - balance: 0
     - last_updated: now()

4. **Create Starter Item:**
   - Query `ItemTypes` table for common rarity items: `SELECT * FROM ItemTypes WHERE rarity = 'common'`
   - Pick 1 random item type
   - Insert into `Items` table:
     - id: generate UUID
     - item_type_id: selected random common item type id
     - user_id: userId
     - level: 1
     - rarity: 'common'
     - craft_count: 0
     - applied_materials: [] (empty array - no materials)
     - computed_stats: copy from ItemTypes.base_stats
     - image_url: null
     - is_styled: false

5. **Initialize Equipment Slots:**
   - Insert 8 rows into `UserEquipment` (one per slot):
     - user_id: userId
     - slot: 'weapon' | 'offhand' | 'head' | 'armor' | 'feet' | 'accessory_1' | 'accessory_2' | 'pet'
     - item_id: null (all empty initially)
     - equipped_at: null

6. **Return UserProfile:**
   - Fetch and return created Users record with computed stats

## Seed Data Reference

Common rarity items available (from `docs/seed-data-items.json`):
- Sword (weapon slot)
- Shield (offhand slot)
- Helmet (head slot)
- Leather Armor (armor slot)
- Boots (feet slot)
- Ring (accessory slot)
- Amulet (accessory slot)

**Note:** Migration `001_initial_schema.sql` must be applied before testing. ItemTypes table should be seeded with these items.

## Questions to Address in Plan

1. **Database Migration:** Should we apply `001_initial_schema.sql` first or work with existing schema?
2. **ItemTypes Seeding:** How do we seed ItemTypes table with common items? Manual SQL or service method?
3. **Random Selection:** Use database `ORDER BY RANDOM() LIMIT 1` or application-level random?
4. **Transaction Safety:** Should profile creation be wrapped in a transaction? (Supabase doesn't support JS SDK transactions natively)
5. **Auth Middleware:** Fix `null as unknown as SupabaseClient` before implementation or work around it?
6. **Type Safety:** What type definitions need to be created/imported? (UserProfile, ItemType, etc.)
7. **Error Handling:** Which error classes to use? (ConflictError, DatabaseError, NotFoundError)

## Expected Plan Structure

Please provide:
1. **Task Breakdown:** Numbered tasks with dependencies
2. **Risk Assessment:** What could go wrong? Edge cases?
3. **Type Definitions:** What types need to be created/imported?
4. **Testing Strategy:** How to validate each step?
5. **Rollback Strategy:** How to handle partial failures?
6. **Recommended Approach:** Your expert opinion on the best way to implement this

**Output Format:** Markdown with clear sections, code snippets where helpful, and explicit dependencies between tasks.

Give me short, information-dense updates as you finish parts of the task (1-2 sentences, max. Incomplete sentences are fine). Only give these updates if you have important information to share. Prepend updates with: [UPDATE]
Started: 2025-10-21T08:56:49.579Z
Status: done
Ended: 2025-10-21T08:58:34.014Z
Depth: 0
ParentAgent: root
---

[
UPDATE
]
 Read
 your
 context
 and
 constraints
.
 Draft
ing
 concise
,
 decision
-ready
 implementation
 plan
 with
 options
 and
 risks
.


###
 Recommended
 approach


-
 Use
 a
 single
 Post
gres
 stored
 procedure
 to
 perform
 profile
 initialization
 atom
ically
 in
 one
 transaction
,
 called
 via
 Sup
abase
 `
rpc
`
 from
 `
Profile
Service
.initialize
Profile
`.
 This
 ensures
 id
empot
ency
 and
 avoids
 partial
 state
 on
 failures
.
 R
ationale
:
 Sup
abase
 JS
 SDK
 lacks
 multi
-st
atement
 transactions
;
 schema
 is
 new
 and
 under
 our
 control
;
 we
 can
 encode
 business
 rules
 in
 SQL
 with
 uniqueness
 constraints
.
 See
 `
CLA
U
DE
.md
`
 notes
 on
 Sup
abase
 and
 migration
 state
 and
 the
 Service
 →
 Controller
 →
 Route
 pattern
 in
 `
src
/
`
 (
Migration
 Status
;
 Environment
 Variables
;
 Request
 Lifecycle
).


##
 
1
)
 Task
 breakdown
 (
with
 dependencies
)

1
.
 Apply
 DB
 schema


  
 -
 Apply
 `
m
igrations
/
001
_initial
_schema
.sql
`
 to
 Sup
abase
.
 Blocking
 prerequisite
 for
 all
 downstream
 data
 operations
.
 

2
.
 Seed
 `
Item
Types
`
 with
 common
 items


  
 -
 Add
 a
 migration
 that
 inserts
 common
 rarity
 rows
 (
Sword
,
 Shield
,
 Helmet
,
 Leather
 Armor
,
 Boots
,
 Ring
,
 Am
ulet
)
 with
 `
rar
ity
='
common
'
`
 and
 valid
 `
slot
`
 and
 `
base
_stats
`.
 Can
 source
 from
 `
docs
/
seed
-data
-items
.json
`
 (
or
 create
 a
 SQL
 seed
 aligned
 to
 it
).

  
 -
 Depends
 on
 step
 
1
.

3
.
 Fix
 auth
 middleware
 to
 use
 real
 Sup
abase
 client


  
 -
 Replace
 `
null
 as
 unknown
 as
 Sup
abase
Client
`
 in
 `
src
/m
iddleware
/auth
.ts
`
 with
 an
 initialized
 client
 and
 attach
 `
req
.user
`
 (
id
,
 email
).
 See
 constraints
 in
 `
CLA
U
DE
.md
`
 Migration
 Status
 and
 Auth
 middleware
 placeholder
 notes
.

  
 -
 Enables
 secure
 access
 to
 `
user
Id
`
 and
 `
email
`
 for
 the
 endpoint
.

4
.
 Create
 SQL
 function
 for
 atomic
 init


  
 -
 New
 migration
:
 `
m
igrations
/create
_profile
_init
_function
.sql
`
 defining
 `
public
.init
_profile
(p
_user
_id
 uuid
,
 p
_email
 text
)`
 that
:

    
 -
 Id
empot
ency
:
 `
if
 exists
(select
 
1
 from
 Users
 where
 id
 =
 p
_user
_id
)
 then
 raise
 exception
 '
conf
lict
:
already
_initialized
';
 end
 if
;
`

    
 -
 Insert
 `
Users
`
 (
defaults
:
 `
van
ity
_level
=
1
`,
 `
avg
_item
_level
=
1
`,
 `
email
`
 from
 param
).

    
 -
 Insert
 `
User
Currency
Balances
`
 with
 `
('
G
OLD
',
 
0
,
 now
())
`.

    
 -
 Select
 
1
 random
 common
 `
Item
Types
`
 via
 `
ORDER
 BY
 random
()
 LIMIT
 
1
`;
 error
 if
 none
.

    
 -
 Insert
 starter
 `
Items
`
 (
level
 
1
,
 rarity
 `
common
`,
 `
craft
_count
=
0
`,
 `
ap
plied
_material
s
=[]
`,
 `
computed
_stats
`
 copied
 from
 `
Item
Types
.base
_stats
`,
 `
image
_url
=null
`,
 `
is
_st
yled
=false
`
).

    
 -
 Insert
 
8
 `
User
Equipment
`
 rows
 with
 `
item
_id
=null
`.

    
 -
 Return
 the
 created
 `
Users
`
 row
.

  
 -
 Depends
 on
 steps
 
1
-
2
.

5
.
 Implement
 `
Profile
Service
.initialize
Profile
`

  
 -
 Call
 `
rpc
('
init
_profile
',
 {
 p
_user
_id
:
 user
Id
,
 p
_email
:
 email
 })
`.

  
 -
 Map
 error
 code
/message
 `
already
_initialized
`
 →
 `
Conflict
Error
('
Profile
 already
 initialized
')
`;
 map
 others
 to
 `
Database
Error
`
/
`
Not
Found
Error
`.

  
 -
 Return
 `
User
Profile
`
 DTO
 (
align
 to
 `
src
/types
/s
chemas
.ts
`
).

  
 -
 Depends
 on
 steps
 
3
-
4
.

6
.
 Wire
 controller
/
route
 and
 validation


  
 -
 Route
 and
 controller
 exist
;
 ensure
 Z
od
 schema
 for
 response
 is
 correct
 and
 controller
 returns
 the
 created
 profile
.
 See
 `
src
/types
/s
chemas
.ts
`
 and
 `
src
/controllers
/Profile
Controller
.ts
`.

7
.
 Tests


  
 -
 Unit
 tests
 for
 service
 (
mock
 Sup
abase
),
 and
 integration
 tests
 against
 a
 test
 Sup
abase
 (
or
 local
 stack
)
 validating
 id
empot
ency
 and
 state
 creation
.

  
 -
 Depends
 on
 steps
 
1
-
5
.


##
 
2
)
 Options
 and
 trade
-offs


-
 Option
 A
:
 Post
gres
 stored
 procedure
 (
RE
COMM
ENDED
)

 -
 Pros
:
 True
 transaction
,
 clean
 id
empot
ency
,
 least
 race
 risk
,
 fewer
 network
 round
tr
ips
.

 -
 Cons
:
 SQL
 complexity
;
 requires
 migration
 +
 RPC
 plumbing
.

-
 Option
 B
:
 App
-layer
 multi
-call
 with
 UPS
ERT
s


 -
 Pros
:
 No
 SQL
 function
 needed
.

 -
 Cons
:
 No
 client
 transactions
;
 risk
 of
 partial
 state
;
 race
 windows
.
 Must
 rely
 on
 unique
 constraints
 and
 “
up
sert
 only
”
 strategy
;
 requires
 careful
 compensation
 logic
.

-
 Option
 C
:
 Id
empot
ency
 key
 table


 -
 Pros
:
 General
 id
empot
ency
 framework
.

 -
 Cons
:
 Over
kill
 here
;
 `
Users
.id
`
 existence
 suff
ices
 as
 guard
.


##
 
3
)
 Edge
 cases
 and
 risks


-
 Duplicate
 concurrent
 in
its
:
 Hand
led
 by
 transaction
 +
 pre
-check
;
 second
 call
 fails
 with
 conflict
;
 no
 partial
 state
 remains
.
 Without
 transaction
,
 must
 rely
 on
 unique
 constraints
 and
 accept
 benign
 no
-
ops
.

-
 Missing
 seed
 data
 (`
Item
Types
`
 with
 `
rar
ity
='
common
'
`
):
 Return
 `
Not
Found
Error
`;
 test
 this
 explicitly
.

-
 R
LS
 permissions
:
 Ensure
 server
 uses
 service
 role
 key
 for
 inserts
 into
 all
 tables
.
 See
 `.
env
.local
`
 keys
 in
 `
CLA
U
DE
.md
`.

-
 Email
 unavailable
:
 If
 `
email
`
 absent
 in
 auth
,
 allow
 `
null
`
 (
per
 requirement
)
 but
 log
;
 ensure
 column
 nullable
.

-
 Enum
 mism
atches
:
 Ensure
 `
rar
ity
`,
 `
slot
`
 enums
 inserts
 match
 DB
 enum
 definitions
 from
 `
001
_initial
_schema
.sql
`.

-
 JSON
 fields
:
 `
computed
_stats
`
 must
 match
 `
Item
Types
.base
_stats
`
 structure
;
 validate
 shape
 before
 insert
 if
 done
 app
-side
.


##
 
4
)
 Type
 definitions


-
 Use
 generated
 Sup
abase
 types
 in
 `
src
/types
/database
.types
.ts
`
:

 -
 `
Database
['
public
']['
Tables
']['
Users
']['
Row
'
|'
Insert
']
`

 -
 `
Database
['
public
']['
Tables
']['
Item
Types
']['
Row
']
`

 -
 `
Database
['
public
']['
Tables
']['
Items
']['
Insert
']
`

 -
 `
Database
['
public
']['
Tables
']['
User
Currency
Balances
']['
Insert
']
`

 -
 `
Database
['
public
']['
Tables
']['
User
Equipment
']['
Insert
']
`

-
 Import
 `
User
Profile
`
 shape
 from
 `
src
/types
/s
chemas
.ts
`
 (
Z
od
 schema
)
 or
 define
 a
 matching
 Type
Script
 type
 if
 needed
.

-
 Enum
 literals
:
 use
 exact
 DB
 values
 for
 `
rar
ity
`
 and
 `
slot
`
 (
see
 schema
 in
 `
001
_initial
_schema
.sql
`
 and
 `
src
/types
/s
chemas
.ts
`
 slots
 list
).


##
 
5
)
 Testing
 strategy


-
 Unit
 tests
 (
mock
ed
 Sup
abase
):

 -
 Happy
 path
:
 returns
 user
 profile
.

 -
 Id
empot
ency
:
 second
 call
 throws
 `
Conflict
Error
`.

 -
 No
 common
 items
:
 throws
 `
Not
Found
Error
`.

 -
 DB
 error
 propagation
:
 `
Database
Error
`
 mapping
.

-
 Integration
 (
local
 Sup
abase
 or
 test
 project
):

 -
 After
 init
:
 verify
 `
Users
`
 row
 values
;
 `
User
Currency
Balances
`
 has
 `(
G
OLD
,
 
0
)`
;
 `
Items
`
 starter
 exists
 and
 is
 `
common
`
 with
 `
computed
_stats
`
 copied
;
 
8
 `
User
Equipment
`
 rows
 empty
.

 -
 Id
empot
ency
 under
 concurrency
:
 fire
 two
 requests
;
 exactly
 one
 succeeds
.

-
 API
 tests
:

 -
 `
POST
 /
api
/v
1
/profile
/init
`
 with
 valid
 JWT
;
 validate
 response
 schema
 and
 
409
 on
 duplicate
.

-
 Fixture
 reset
:
 truncate
 changed
 tables
 between
 runs
;
 or
 reset
 DB
 schema
.


##
 
6
)
 Roll
back
 strategy


-
 With
 SQL
 function
:
 transaction
 ensures
 automatic
 rollback
 on
 any
 error
;
 no
 partial
 writes
.

-
 Without
 function
 (
fallback
):
 

 -
 Use
 only
 UPS
ERT
s
 with
 `
ON
 CON
FLICT
 DO
 NOTHING
`
 and
 read
-after
-write
 to
 determine
 resulting
 state
.

 -
 If
 an
 error
 occurs
 mid
-flow
,
 subsequent
 init
 attempts
 should
 complete
 missing
 pieces
 id
empot
ently
.
 Avoid
 manual
 cleanup
.


##
 
7
)
 Implementation
 details



-
 SQL
 function
 (
outline
)

```
sql


--
 migrations
/create
_profile
_init
_function
.sql


create
 or
 replace
 function
 public
.init
_profile
(p
_user
_id
 uuid
,
 p
_email
 text
)

returns
 public
."
Users
"

language
 pl
pgsql


security
 def
iner


set
 search
_path
 =
 public


as
 $
$

declare


 v
_user
 public
."
Users
"%
row
type
;

 v
_item
_type
 public
."
Item
Types
"%
row
type
;

 v
_item
_id
 uuid
 :=
 gen
_random
_uuid
();

begin


 if
 exists
 (
select
 
1
 from
 public
."
Users
"
 where
 id
 =
 p
_user
_id
)
 then


   
 raise
 exception
 '
conf
lict
:
already
_initialized
';

 end
 if
;


 insert
 into
 public
."
Users
"(
id
,
 email
,
 username
,
 vanity
_level
,
 avg
_item
_level
)

 values
 (
p
_user
_id
,
 p
_email
,
 null
,
 
1
,
 
1
)

 returning
 *
 into
 v
_user
;


 insert
 into
 public
."
User
Currency
Balances
"(
user
_id
,
 currency
_code
,
 balance
,
 last
_updated
)

 values
 (
p
_user
_id
,
 '
G
OLD
',
 
0
,
 now
());


 select
 *
 into
 v
_item
_type


 from
 public
."
Item
Types
"

 where
 rarity
 =
 '
common
'

 order
 by
 random
()

 limit
 
1
;


 if
 not
 found
 then


   
 raise
 exception
 '
not
_found
:
common
_item
_type
_missing
';

 end
 if
;


 insert
 into
 public
."
Items
"(
id
,
 item
_type
_id
,
 user
_id
,
 level
,
 rarity
,
 craft
_count
,

                            
 applied
_material
s
,
 computed
_stats
,
 image
_url
,
 is
_st
yled
)

 values
 (
v
_item
_id
,
 v
_item
_type
.id
,
 p
_user
_id
,
 
1
,
 '
common
',
 
0
,

         
 '
[]
'
::
json
b
,
 v
_item
_type
.base
_stats
,
 null
,
 false
);


 insert
 into
 public
."
User
Equipment
"(
user
_id
,
 slot
,
 item
_id
,
 equipped
_at
)

 select
 p
_user
_id
,
 s
.slot
::
public
."
Equipment
Slot
",
 null
,
 null


 from
 (
values


       
 ('
weapon
'),
 ('
off
hand
'),
 ('
head
'),
 ('
armor
'),

       
 ('
feet
'),
 ('
access
ory
_
1
'),
 ('
access
ory
_
2
'),
 ('
pet
'))
 as
 s
(slot
);


 return
 v
_user
;

end
;

$$
;

``
`


-
 Service
 method
 (
shape
)

```
ts


//
 src
/services
/Profile
Service
.ts


import
 {
 Sup
abase
Client
 }
 from
 '@
sup
abase
/s
up
abase
-js
';

import
 {
 Conflict
Error
,
 Not
Found
Error
 }
 from
 '../
utils
/errors
';

import
 {
 Database
 }
 from
 '../
types
/database
.types
';


export
 class
 Profile
Service
 {

 constructor
(private
 readonly
 sup
abase
:
 Sup
abase
Client
<
Database
>)
 {}


 async
 initialize
Profile
(user
Id
:
 string
,
 email
:
 string
 |
 null
)
 {

   
 const
 {
 data
,
 error
 }
 =
 await
 this
.sup
abase
.rpc
('
init
_profile
',
 {

     
 p
_user
_id
:
 user
Id
,

     
 p
_email
:
 email
,

   
 });


   
 if
 (
error
)
 {

     
 if
 (
error
.message
?.
includes
('
already
_initialized
'))
 {

       
 throw
 new
 Conflict
Error
('
Profile
 already
 initialized
');

     
 }

     
 if
 (
error
.message
?.
includes
('
common
_item
_type
_missing
'))
 {

       
 throw
 new
 Not
Found
Error
('
No
 common
 item
 types
 available
');

     
 }

     
 throw
 map
Sup
abase
Error
(error
);

   
 }


   
 return
 data
;
 //
 shape
 should
 match
 User
Profile
 schema


 }

}

``
`


-
 F
allback
 (
if
 SQL
 function
 not
 immediately
 available
):
 perform
 app
-layer
 sequence
 with
 UPS
ERT
s
,
 mapping
 conflicts
 to
 `
Conflict
Error
`,
 and
 selecting
 random
 common
 item
 via
 `
select
(...
).
eq
('
rar
ity
','
common
').
order
('
random
')
`
 if
 supported
,
 or
 fetch
 and
 `
Math
.random
()`
 client
-side
.
 Prefer
 DB
 `
ORDER
 BY
 random
()`
 to
 keep
 selection
 atomic
 and
 unbiased
.


##
 
8
)
 Answers
 to
 specific
 questions


-
 Database
 Migration
:
 Apply
 `
001
_initial
_schema
.sql
`
 first
.
 Nothing
 else
 is
 viable
 without
 the
 schema
.

-
 Item
Types
 Se
eding
:
 Seed
 via
 migration
 SQL
 aligned
 with
 `
docs
/
seed
-data
-items
.json
`.
 Keep
 seed
 deterministic
 and
 id
empot
ent
 (`
ON
 CON
FLICT
 DO
 NOTHING
`
).

-
 Random
 Selection
:
 Prefer
 DB
 `
ORDER
 BY
 random
()
 LIMIT
 
1
`
 inside
 the
 SQL
 function
 for
 atomic
ity
.

-
 Transaction
 Safety
:
 Yes
—
wrap
 the
 entire
 flow
 in
 a
 Post
gres
 function
 (
transaction
al
 by
 default
 in
 PL
/
pg
SQL
).

-
 Auth
 Middleware
:
 Fix
 it
 before
 shipping
.
 For
 the
 service
 call
,
 pass
 `
user
Id
`
 and
 `
email
`
 from
 `
req
.user
`
 populated
 by
 a
 real
 Sup
abase
 client
;
 server
 must
 use
 service
 role
 key
.

-
 Type
 Safety
:
 Use
 `
src
/types
/database
.types
.ts
`
 table
 types
 and
 the
 `
User
Profile
`
 schema
 (
Z
od
)
 in
 `
src
/types
/s
chemas
.ts
`;
 no
 `
any
`.

-
 Error
 Handling
:
 Use
 `
Conflict
Error
`,
 `
Not
Found
Error
`,
 `
Database
Error
`
/
`
map
Sup
abase
Error
`
 per
 existing
 patterns
.
 Ensure
 consistent
 mapping
 in
 controller
.


[
UPDATE
]
 Decision
:
 Recommend
 SQL
 function
 +
 RPC
 approach
.
 App
-layer
 fallback
 only
 if
 DB
 function
 cannot
 ship
 immediately
.


-
 Key
 dependencies
 and
 constraints
 referenced
:
 `
CLA
U
DE
.md
`
 (
Migration
 Status
;
 Environment
 Variables
;
 Database
 Schema
 notes
;
 Equipment
 slots
 in
 `
schemas
.ts
`
),
 `
m
igrations
/
001
_initial
_schema
.sql
`
 (
tables
/en
ums
),
 `
src
/types
/database
.types
.ts
`
 (
generated
 Sup
abase
 types
),
 `
src
/m
iddleware
/auth
.ts
`
 (
placeholder
 to
 fix
),
 `
src
/services
/Profile
Service
.ts
`
 (
target
 method
).


-
 Summary


 -
 Implement
 atomic
 profile
 init
 via
 Post
gres
 function
 invoked
 by
 `
Profile
Service
.initialize
Profile
`,
 ensuring
 id
empot
ency
 and
 correct
 initial
 state
 (
0
 gold
,
 one
 random
 common
 item
,
 
8
 empty
 equipment
 slots
).

 -
 Apply
 base
 schema
,
 seed
 `
Item
Types
`,
 fix
 auth
 middleware
,
 then
 add
 function
 and
 service
 integration
.

 -
 Tests
 cover
 happy
 path
,
 id
empot
ency
,
 missing
 seeds
,
 and
 DB
 error
 mapping
.
[UPDATE] Read your context and constraints. Drafting concise, decision-ready implementation plan with options and risks.

### Recommended approach
- Use a single Postgres stored procedure to perform profile initialization atomically in one transaction, called via Supabase `rpc` from `ProfileService.initializeProfile`. This ensures idempotency and avoids partial state on failures. Rationale: Supabase JS SDK lacks multi-statement transactions; schema is new and under our control; we can encode business rules in SQL with uniqueness constraints. See `CLAUDE.md` notes on Supabase and migration state and the Service → Controller → Route pattern in `src/` (Migration Status; Environment Variables; Request Lifecycle).

## 1) Task breakdown (with dependencies)
1. Apply DB schema
   - Apply `migrations/001_initial_schema.sql` to Supabase. Blocking prerequisite for all downstream data operations. 
2. Seed `ItemTypes` with common items
   - Add a migration that inserts common rarity rows (Sword, Shield, Helmet, Leather Armor, Boots, Ring, Amulet) with `rarity='common'` and valid `slot` and `base_stats`. Can source from `docs/seed-data-items.json` (or create a SQL seed aligned to it).
   - Depends on step 1.
3. Fix auth middleware to use real Supabase client
   - Replace `null as unknown as SupabaseClient` in `src/middleware/auth.ts` with an initialized client and attach `req.user` (id, email). See constraints in `CLAUDE.md` Migration Status and Auth middleware placeholder notes.
   - Enables secure access to `userId` and `email` for the endpoint.
4. Create SQL function for atomic init
   - New migration: `migrations/create_profile_init_function.sql` defining `public.init_profile(p_user_id uuid, p_email text)` that:
     - Idempotency: `if exists(select 1 from Users where id = p_user_id) then raise exception 'conflict:already_initialized'; end if;`
     - Insert `Users` (defaults: `vanity_level=1`, `avg_item_level=1`, `email` from param).
     - Insert `UserCurrencyBalances` with `('GOLD', 0, now())`.
     - Select 1 random common `ItemTypes` via `ORDER BY random() LIMIT 1`; error if none.
     - Insert starter `Items` (level 1, rarity `common`, `craft_count=0`, `applied_materials=[]`, `computed_stats` copied from `ItemTypes.base_stats`, `image_url=null`, `is_styled=false`).
     - Insert 8 `UserEquipment` rows with `item_id=null`.
     - Return the created `Users` row.
   - Depends on steps 1-2.
5. Implement `ProfileService.initializeProfile`
   - Call `rpc('init_profile', { p_user_id: userId, p_email: email })`.
   - Map error code/message `already_initialized` → `ConflictError('Profile already initialized')`; map others to `DatabaseError`/`NotFoundError`.
   - Return `UserProfile` DTO (align to `src/types/schemas.ts`).
   - Depends on steps 3-4.
6. Wire controller/route and validation
   - Route and controller exist; ensure Zod schema for response is correct and controller returns the created profile. See `src/types/schemas.ts` and `src/controllers/ProfileController.ts`.
7. Tests
   - Unit tests for service (mock Supabase), and integration tests against a test Supabase (or local stack) validating idempotency and state creation.
   - Depends on steps 1-5.

## 2) Options and trade-offs
- Option A: Postgres stored procedure (RECOMMENDED)
  - Pros: True transaction, clean idempotency, least race risk, fewer network roundtrips.
  - Cons: SQL complexity; requires migration + RPC plumbing.
- Option B: App-layer multi-call with UPSERTs
  - Pros: No SQL function needed.
  - Cons: No client transactions; risk of partial state; race windows. Must rely on unique constraints and “upsert only” strategy; requires careful compensation logic.
- Option C: Idempotency key table
  - Pros: General idempotency framework.
  - Cons: Overkill here; `Users.id` existence suffices as guard.

## 3) Edge cases and risks
- Duplicate concurrent inits: Handled by transaction + pre-check; second call fails with conflict; no partial state remains. Without transaction, must rely on unique constraints and accept benign no-ops.
- Missing seed data (`ItemTypes` with `rarity='common'`): Return `NotFoundError`; test this explicitly.
- RLS permissions: Ensure server uses service role key for inserts into all tables. See `.env.local` keys in `CLAUDE.md`.
- Email unavailable: If `email` absent in auth, allow `null` (per requirement) but log; ensure column nullable.
- Enum mismatches: Ensure `rarity`, `slot` enums in inserts match DB enum definitions from `001_initial_schema.sql`.
- JSON fields: `computed_stats` must match `ItemTypes.base_stats` structure; validate shape before insert if done app-side.

## 4) Type definitions
- Use generated Supabase types in `src/types/database.types.ts`:
  - `Database['public']['Tables']['Users']['Row'|'Insert']`
  - `Database['public']['Tables']['ItemTypes']['Row']`
  - `Database['public']['Tables']['Items']['Insert']`
  - `Database['public']['Tables']['UserCurrencyBalances']['Insert']`
  - `Database['public']['Tables']['UserEquipment']['Insert']`
- Import `UserProfile` shape from `src/types/schemas.ts` (Zod schema) or define a matching TypeScript type if needed.
- Enum literals: use exact DB values for `rarity` and `slot` (see schema in `001_initial_schema.sql` and `src/types/schemas.ts` slots list).

## 5) Testing strategy
- Unit tests (mocked Supabase):
  - Happy path: returns user profile.
  - Idempotency: second call throws `ConflictError`.
  - No common items: throws `NotFoundError`.
  - DB error propagation: `DatabaseError` mapping.
- Integration (local Supabase or test project):
  - After init: verify `Users` row values; `UserCurrencyBalances` has `(GOLD, 0)`; `Items` starter exists and is `common` with `computed_stats` copied; 8 `UserEquipment` rows empty.
  - Idempotency under concurrency: fire two requests; exactly one succeeds.
- API tests:
  - `POST /api/v1/profile/init` with valid JWT; validate response schema and 409 on duplicate.
- Fixture reset: truncate changed tables between runs; or reset DB schema.

## 6) Rollback strategy
- With SQL function: transaction ensures automatic rollback on any error; no partial writes.
- Without function (fallback): 
  - Use only UPSERTs with `ON CONFLICT DO NOTHING` and read-after-write to determine resulting state.
  - If an error occurs mid-flow, subsequent init attempts should complete missing pieces idempotently. Avoid manual cleanup.

## 7) Implementation details

- SQL function (outline)
```sql
-- migrations/create_profile_init_function.sql
create or replace function public.init_profile(p_user_id uuid, p_email text)
returns public."Users"
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user public."Users"%rowtype;
  v_item_type public."ItemTypes"%rowtype;
  v_item_id uuid := gen_random_uuid();
begin
  if exists (select 1 from public."Users" where id = p_user_id) then
    raise exception 'conflict:already_initialized';
  end if;

  insert into public."Users"(id, email, username, vanity_level, avg_item_level)
  values (p_user_id, p_email, null, 1, 1)
  returning * into v_user;

  insert into public."UserCurrencyBalances"(user_id, currency_code, balance, last_updated)
  values (p_user_id, 'GOLD', 0, now());

  select * into v_item_type
  from public."ItemTypes"
  where rarity = 'common'
  order by random()
  limit 1;

  if not found then
    raise exception 'not_found:common_item_type_missing';
  end if;

  insert into public."Items"(id, item_type_id, user_id, level, rarity, craft_count,
                             applied_materials, computed_stats, image_url, is_styled)
  values (v_item_id, v_item_type.id, p_user_id, 1, 'common', 0,
          '[]'::jsonb, v_item_type.base_stats, null, false);

  insert into public."UserEquipment"(user_id, slot, item_id, equipped_at)
  select p_user_id, s.slot::public."EquipmentSlot", null, null
  from (values
        ('weapon'), ('offhand'), ('head'), ('armor'),
        ('feet'), ('accessory_1'), ('accessory_2'), ('pet')) as s(slot);

  return v_user;
end;
$$;
```

- Service method (shape)
```ts
// src/services/ProfileService.ts
import { SupabaseClient } from '@supabase/supabase-js';
import { ConflictError, NotFoundError } from '../utils/errors';
import { Database } from '../types/database.types';

export class ProfileService {
  constructor(private readonly supabase: SupabaseClient<Database>) {}

  async initializeProfile(userId: string, email: string | null) {
    const { data, error } = await this.supabase.rpc('init_profile', {
      p_user_id: userId,
      p_email: email,
    });

    if (error) {
      if (error.message?.includes('already_initialized')) {
        throw new ConflictError('Profile already initialized');
      }
      if (error.message?.includes('common_item_type_missing')) {
        throw new NotFoundError('No common item types available');
      }
      throw mapSupabaseError(error);
    }

    return data; // shape should match UserProfile schema
  }
}
```

- Fallback (if SQL function not immediately available): perform app-layer sequence with UPSERTs, mapping conflicts to `ConflictError`, and selecting random common item via `select(...).eq('rarity','common').order('random')` if supported, or fetch and `Math.random()` client-side. Prefer DB `ORDER BY random()` to keep selection atomic and unbiased.

## 8) Answers to specific questions
- Database Migration: Apply `001_initial_schema.sql` first. Nothing else is viable without the schema.
- ItemTypes Seeding: Seed via migration SQL aligned with `docs/seed-data-items.json`. Keep seed deterministic and idempotent (`ON CONFLICT DO NOTHING`).
- Random Selection: Prefer DB `ORDER BY random() LIMIT 1` inside the SQL function for atomicity.
- Transaction Safety: Yes—wrap the entire flow in a Postgres function (transactional by default in PL/pgSQL).
- Auth Middleware: Fix it before shipping. For the service call, pass `userId` and `email` from `req.user` populated by a real Supabase client; server must use service role key.
- Type Safety: Use `src/types/database.types.ts` table types and the `UserProfile` schema (Zod) in `src/types/schemas.ts`; no `any`.
- Error Handling: Use `ConflictError`, `NotFoundError`, `DatabaseError`/`mapSupabaseError` per existing patterns. Ensure consistent mapping in controller.

[UPDATE] Decision: Recommend SQL function + RPC approach. App-layer fallback only if DB function cannot ship immediately.

- Key dependencies and constraints referenced: `CLAUDE.md` (Migration Status; Environment Variables; Database Schema notes; Equipment slots in `schemas.ts`), `migrations/001_initial_schema.sql` (tables/enums), `src/types/database.types.ts` (generated Supabase types), `src/middleware/auth.ts` (placeholder to fix), `src/services/ProfileService.ts` (target method).

- Summary
  - Implement atomic profile init via Postgres function invoked by `ProfileService.initializeProfile`, ensuring idempotency and correct initial state (0 gold, one random common item, 8 empty equipment slots).
  - Apply base schema, seed `ItemTypes`, fix auth middleware, then add function and service integration.
  - Tests cover happy path, idempotency, missing seeds, and DB error mapping.